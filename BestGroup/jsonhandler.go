package main

import (
	"encoding/json"
	"errors"
	"io/ioutil"
	"os"
	"sort"
	"strconv"
	"sync"
	"time"
)

type OAuthAccessResponse struct {
	AccessToken string `json:"access_token"`
}

type Users struct {
	Users []User `json:"users"`
}

type User struct {
	Id                int
	Username          string
	Gthb_identifier   string
	Avatar_url        string
	token             string
	Rights            int
	Files_permissions []int
}

type Node struct {
	ID           int `json:"id"`
	EndDeviceIds struct {
		DeviceID       string `json:"device_id"`
		ApplicationIds struct {
			ApplicationID string `json:"application_id"`
		} `json:"application_ids"`
		DevEui  string `json:"dev_eui"`
		JoinEui string `json:"join_eui"`
	} `json:"end_device_ids"`
	CorrelationIds []string  `json:"correlation_ids"`
	ReceivedAt     time.Time `json:"received_at"`
	UplinkMessage  struct {
		FPort      int    `json:"f_port"`
		FrmPayload string `json:"frm_payload"`
		RxMetadata []struct {
			GatewayIds struct {
				GatewayID string `json:"gateway_id"`
			} `json:"gateway_ids"`
			Rssi        int     `json:"rssi"`
			ChannelRssi int     `json:"channel_rssi"`
			Snr         float64 `json:"snr"`
		} `json:"rx_metadata"`
		Settings struct {
			DataRate struct {
				Lora struct {
					Bandwidth       int `json:"bandwidth"`
					SpreadingFactor int `json:"spreading_factor"`
				} `json:"lora"`
			} `json:"data_rate"`
		} `json:"settings"`
	} `json:"uplink_message"`
	Simulated bool `json:"simulated"`
}

type Decrypted struct {
	ID                 int  `json:"id"`
	LEDBrightness      int  `json:"led_brightness"`
	LEDUsage           int  `json:"led_usage"`
	DeadLEDs           int  `json:"dead_leds"`
	IsPowered          bool `json:"is_powered"`
	ZMCTError          bool `json:"zmct_error"`
	XY_MOSError        bool `json:"xy_mos_error"`
	ACSError           bool `json:"acs_error"`
	PhotoresistorError bool `json:"photoresistor_error"`
	RequestBackupData  bool `json:"request_backup_data"`
}

type AutoGenerated struct {
	Nodes     []Node      `json:"nodes"`
	Decrypted []Decrypted `json:"decrypted"`
}

type NodesI struct {
	EndNodes []NodeI `json:"endnodes"`
}

type NodeI struct {
	Name       string `json:"name"`
	FileHash   string `json:"filehash"`
	APIKey     string `json:"apikey"`
	WebhookAPI string `json:"webhookapi"`
	ID         int    `json:"id"`
}

type Apps struct {
	Apps []App `json:"apps"`
}

type App struct {
	ID          int    `json:"id"`
	Name        string `json:"name"`
	Version     string `json:"version"`
	Description string `json:"description"`
	Author      string `json:"author"`
	Link        string `json:"link"`
}

var (
	muNodes       sync.RWMutex
	Nodes         []AutoGenerated
	EraseInBackUp = []string{}
	UsersI        Users
	NodesFiles    NodesI
	AppsI         Apps
)

func InitJSON(jsonI string, Stype uint8) error {
	jsonFile, err := os.Open(jsonI)
	if err != nil {
		return err
	}
	defer jsonFile.Close()

	// read our opened jsonFile as a byte array.
	byteValue, err := ioutil.ReadAll(jsonFile)
	if err != nil {
		return err
	}
	if Stype == 0 {
		temp := AutoGenerated{}
		json.Unmarshal(byteValue, &temp)
		Nodes = append(Nodes, temp)
		return nil
	} else if Stype == 1 {
		json.Unmarshal(byteValue, &UsersI)
		return nil
	} else if Stype == 2 {
		json.Unmarshal(byteValue, &NodesFiles)
		return nil
	} else if Stype == 3 {
		json.Unmarshal(byteValue, &AppsI)
		return nil
	}
	return errors.New("wrong type")
}

func SaveJSON(jsonI string, data1 AutoGenerated, data2 Users, data3 NodesI) error {
	muNodes.Lock()
	defer muNodes.Unlock()

	// open output file
	jsonFile, err := os.OpenFile(jsonI, os.O_WRONLY|os.O_TRUNC, 0644)
	if err != nil {
		return err
	}
	defer jsonFile.Close()

	var jsonData []byte
	if data1.Nodes != nil {
		// convert to json
		jsonData, err = json.Marshal(data1)
	} else if data2.Users != nil {
		// convert to json
		jsonData, err = json.Marshal(data2)
	} else if data3.EndNodes != nil {
		// convert to json
		jsonData, err = json.Marshal(data3)
	} else {
		return errors.New("wrong type")
	}
	if err != nil {
		return err
	}

	//write to file
	_, err = jsonFile.Write(jsonData)
	if err != nil {
		return err
	}
	return nil
}

// func GetPlayer(name string) (EndNode, error) {
// 	muNodes.RLock()
// 	defer muNodes.RUnlock()
// 	for _, node := range Nodes.Nodes {
// 		if node.Name == name {
// 			return node, nil
// 		}
// 	}
// 	return EndNode{}, errors.New("node not found in getplayer")
// }

// func SetPlayer(name string) (int, error) {
// 	muNodes.Lock()
// 	defer muNodes.Unlock()
// 	for i, node := range Nodes.Nodes {
// 		if node.Name == name {
// 			wins := Nodes.Nodes[i].Wins + 1
// 			Nodes.Nodes[i].Wins = wins
// 			return wins, nil
// 		}
// 	}
// 	return -1, errors.New("node not found in setplayer")
// }

// func RemovePlayer(name string) error {
// 	muNodes.Lock()
// 	defer muNodes.Unlock()
// 	for i, node := range Nodes.Nodes {
// 		if node.Name == name {
// 			Nodes.Nodes = append(Nodes.Nodes[:i], Nodes.Nodes[i+1:]...)
// 			return nil
// 		}
// 	}
// 	return errors.New("node not found in removeplayer")
// }

// func AddPlayer(name string) error {
// 	muNodes.Lock()
// 	defer muNodes.Unlock()
// 	for _, node := range Nodes.Nodes {
// 		if node.Name == name {
// 			return errors.New("node already exists")
// 		}
// 	}
// 	Nodes.Nodes = append(Nodes.Nodes, EndNode{Name: name, Wins: 0})
// 	return nil
// }

func FormatNodes(format string, id int) (string, error) {
	muNodes.RLock()
	defer muNodes.RUnlock()
	switch format {
	case "string":
		// Nodes to string in var str
		var str string
		for _, node := range Nodes[id].Nodes {
			str += strconv.Itoa(int(node.ReceivedAt.Hour())) + "\n"
		}
		return str, nil
	case "csv":
		var str string
		str += "Name,Wins\n"
		// Nodes to string in var str
		for _, node := range Nodes[id].Nodes {
			str += node.EndDeviceIds.DeviceID + "," + strconv.Itoa(int(node.ReceivedAt.Hour())) + "\n"
		}
		return str, nil
	case "html":
		var str string
		str += "<table>\n"
		str += "<tr><th>Name</th><th>Wins</th></tr>\n"
		// Nodes to string in var str
		for _, node := range Nodes[id].Nodes {
			str += "<tr><td>" + node.EndDeviceIds.DeviceID + "</td><td>" + strconv.Itoa(int(node.ReceivedAt.Hour())) + "</td></tr>\n"
		}
		str += "</table>\n"
		return str, nil
	case "xml":
		var str string
		str += "<Nodes>\n"
		// Nodes to string in var str
		for _, node := range Nodes[id].Nodes {
			str += "<node>\n"
			str += "<name>" + node.EndDeviceIds.DeviceID + "</name>\n"
			str += "<wins>" + strconv.Itoa(int(node.ReceivedAt.Hour())) + "</wins>\n"
			str += "</node>\n"
		}
		str += "</Nodes>\n"
		return str, nil
	default:
		// convert to json
		jsonData, err := json.Marshal(Nodes)
		if err != nil {
			return "", err
		}
		return string(jsonData), nil
	}
}

// Make backups of the json file in 3 other files
func Backup(timeMult int, jsonI2 string, jsonI3 string, jsonI4 string) {
	// make a goroutine backup of the original file every 30 minute in jsonI2, jsonI3, jsonI4
	go func() {
		nbrTrack := 0
		for range time.Tick(time.Duration(timeMult) * time.Minute) {
			func() {
				muNodes.Lock()
				defer muNodes.Unlock()
				var jsonFile *os.File
				var err error
				switch nbrTrack {
				case 0:
					// open output files
					jsonFile, err = os.OpenFile(jsonI2, os.O_WRONLY|os.O_TRUNC, 0644)
					if err != nil {
						return
					}
				case 1:
					jsonFile, err = os.OpenFile(jsonI2, os.O_WRONLY|os.O_TRUNC, 0644)
					if err != nil {
						return
					}
				default:
					jsonFile, err = os.OpenFile(jsonI2, os.O_WRONLY|os.O_TRUNC, 0644)
					if err != nil {
						return
					}
				}

				defer jsonFile.Close()

				// convert to json
				jsonData, err := json.Marshal(Nodes)
				if err != nil {
					return
				}

				//write to file
				_, err = jsonFile.Write(jsonData)
				if err != nil {
					return
				}
				nbrTrack++
				if nbrTrack > 2 {
					nbrTrack = 0
				}
			}()
		}
	}()
}

func GetNodes(ids []int) string {
	muNodes.RLock()
	defer muNodes.RUnlock()
	//loop through nodes and add them one by one <li class="list-group-item">An item</li>
	var str string
	count := 0
	count2 := 0
	//id in ids
	for _, id := range ids {
		//check if Nodes[id] exists else return error
		if len(Nodes) < id || len(Nodes) == 0 {
			return strconv.FormatFloat(float64(id), 'f', 0, 64) + " is not a valid id when Nodes has a length of " + strconv.FormatFloat(float64(len(Nodes)), 'f', 0, 64)
		}
		str += "<div id=\"card" + strconv.Itoa(count2) + "\">"
		SortNodes(id)
		fChild := true
		for _, node := range Nodes[id].Nodes {
			//check if Nodes.Decrypted[count] is not nil
			str += "<ul class=\"list-group list-group-horizontal\" style=\"justify-content: center;\">"
			str += "<li class=\"list-group-item\" style=\"min-width: 56px;width: 56px;\">" + strconv.Itoa(node.ID) + "</li>"
			str += "<li class=\"list-group-item\""
			if fChild {
				str += " id=\"fChild" + strconv.Itoa(count2) + "\""
				fChild = false
			}
			str += ">"
			//list data in <li> tags  : receivedAt, application_id, endDeviceIds, uplinkMessage
			str += node.ReceivedAt.String() + "</li> <li class=\"list-group-item\">"
			str += node.EndDeviceIds.ApplicationIds.ApplicationID + "</li> <li class=\"list-group-item\">"
			str += node.EndDeviceIds.DeviceID + "</li> <li class=\"list-group-item\">"
			str += strconv.Itoa(node.UplinkMessage.FPort) + ", " + node.UplinkMessage.FrmPayload

			//check if Nodes.Decrypted[count] exists and ID is the same
			if len(Nodes[id].Decrypted) > count && Nodes[id].Decrypted[count].ID == node.ID {
				str += "<div class=\"tooltiptext\"><div class=\"tltptxt\"><ul><li>brightness %</li><li>dead LEDs %</li><li>LED usage</li><li>errors</li></ul><ul class=\"data-ul\"><li>" + strconv.Itoa(Nodes[id].Decrypted[count].LEDBrightness) + "</li><li>" + strconv.Itoa(Nodes[id].Decrypted[count].LEDUsage) + "</li><li>" + strconv.Itoa(Nodes[id].Decrypted[count].DeadLEDs) + "</li><li>" + strconv.FormatBool(Nodes[id].Decrypted[count].IsPowered) + ", " + strconv.FormatBool(Nodes[id].Decrypted[count].ZMCTError) + ", " + strconv.FormatBool(Nodes[id].Decrypted[count].XY_MOSError) + ", " + strconv.FormatBool(Nodes[id].Decrypted[count].ACSError) + ", " + strconv.FormatBool(Nodes[id].Decrypted[count].PhotoresistorError) + ", " + strconv.FormatBool(Nodes[id].Decrypted[count].RequestBackupData) + "</li></ul></div></div>"
				count++
			}

			str += "</li> <li class=\"list-group-item\">" + strconv.FormatBool(node.Simulated)
			str += "</li></ul>"
		}
		str += "</div>"
		count2++
	}
	return str
}

func SortNodes(id int) {
	//sort nodes.nodes nodes.decrypted by biggest id first
	sort.Slice(Nodes[id].Nodes, func(i, j int) bool {
		return Nodes[id].Nodes[i].ID > Nodes[id].Nodes[j].ID
	})

	sort.Slice(Nodes[id].Decrypted, func(i, j int) bool {
		return Nodes[id].Decrypted[i].ID > Nodes[id].Decrypted[j].ID
	})
}
