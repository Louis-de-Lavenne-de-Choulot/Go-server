package main

import (
	"encoding/hex"
	"encoding/json"
	"io/ioutil"
	"net/http"
)

func PostService(w http.ResponseWriter, r *http.Request) {
	if len(r.URL.Path) > 50 {
		r.URL.Path = r.URL.Path[:50]
	}

	logrequest(r)
	// check if the option ?format is present and get the value
	// format := r.URL.Query().Get("format")
	println("called")

	// //print all request
	// for key, value := range r.URL.Query() {
	// 	println(key, value)
	// }
	// for key, value := range r.Header {
	// 	println(key, value)
	// }

	//get or post
	println(r.Method)
	switch r.Method {
	case http.MethodPost:
		// read the body
		body, err := ioutil.ReadAll(r.Body)
		if err != nil {
			loganswer("Error reading body")
			println("Error reading body")
			http.Error(w, "can't read body", http.StatusBadRequest)
			return
		}
		//translate json to AutoGenerated
		var no Node
		if err := json.Unmarshal(body, &no); err != nil {
			loganswer("Error unmarshalling json")
			println("Error unmarshalling json")
			http.Error(w, "can't unmarshal json", http.StatusBadRequest)
			return
		}
		id := 0
		name := ""
		found := false
		//loop through FileHashes and check if the node is in the list by name
		for _, file := range NodesFiles.EndNodes {
			if file.Name == no.EndDeviceIds.ApplicationIds.ApplicationID {
				id = file.ID
				name = file.FileHash
				found = true
			}
		}
		//if the node is not in the list, create
		if !found {
			//create new filehash
			name = RandStringBytesRmndr(32)
			//create new node
			NodesFiles.EndNodes = append(NodesFiles.EndNodes, NodeI{Name: no.EndDeviceIds.ApplicationIds.ApplicationID, FileHash: name, ID: len(NodesFiles.EndNodes) - 1})
			//write to file
			ioutil.WriteFile("nodes/"+name+".json", []byte("{}"), 0644)
			id = len(Nodes) - 1
			//save NodesFiles to end-nodes.json
			SaveJSON("end-nodes.json", AutoGenerated{}, Users{}, NodesFiles)
			//add an entry to Nodes
			Nodes = append(Nodes, AutoGenerated{})
		}

		if len(Nodes[id].Nodes) != 0 {
			//search newest node id and add 1
			no.ID = Nodes[id].Nodes[0].ID + 1
		} else {
			no.ID = 1
		}

		//if no.Simulated exists then do base64Tohex
		if no.Simulated {
			no.UplinkMessage.FrmPayload = base64tohex(no.UplinkMessage.FrmPayload)
		} else {
			//get value of the key "frm_payload" in key "uplink_message"
			no.UplinkMessage.FrmPayload = base64Toutf8(no.UplinkMessage.FrmPayload)
		}

		//add dat to Nodes of type AutoGenerated
		Nodes[id].Nodes = append(Nodes[id].Nodes, no)
		Nodes[id].Decrypted = append(Nodes[id].Decrypted, Decrypt(no.UplinkMessage.FrmPayload))

		if len(Nodes[id].Decrypted) != 0 {
			//search newest node id and add no.ID
			Nodes[id].Decrypted[len(Nodes[id].Decrypted)-1].ID = no.ID
		} else {
			Nodes[id].Decrypted[0].ID = no.ID
		}

		//save the Nodes in end-nodes.json
		err = SaveJSON("nodes/"+name+".json", Nodes[id], Users{}, NodesI{})
		if err != nil {
			loganswer("Error saving json")
			println("Error saving json")
			http.Error(w, "can't save json", http.StatusBadRequest)
			return
		}

		loganswer("request validated")
		w.WriteHeader(http.StatusAccepted)
	case http.MethodGet:

		w.WriteHeader(http.StatusMethodNotAllowed)
		println("Method not allowed")
		loganswer("Method not allowed")
	default:
		w.WriteHeader(http.StatusMethodNotAllowed)
		println("Method not allowed")
		loganswer("Method not allowed")
	}
}

func Decrypt(hexstring string) Decrypted {
	if len(hexstring) < 8 {
		return Decrypted{}
	}
	dec := Decrypted{}
	//convert hexstring to byte array
	hex, err := hex.DecodeString(hexstring)
	if err != nil {
		println("Error decoding hexstring")
		return dec
	}
	// get 1st byte and convert it to int
	dec.LEDBrightness = int(hex[0])

	// get 2nd byte and convert it to int
	dec.LEDUsage = int(hex[1])

	// get 3rd byte and convert it to int
	dec.DeadLEDs = int(hex[2])

	// get 4th byte and get it bit by bit
	//first bit return bool
	dec.IsPowered = (hex[3] & 0x80) != 0
	//second bit return bool
	dec.ZMCTError = (hex[3] & 0x40) != 0
	//third bit return bool
	dec.XY_MOSError = (hex[3] & 0x20) != 0
	//fourth bit return bool
	dec.ACSError = (hex[3] & 0x10) != 0
	//fifth bit return bool
	dec.PhotoresistorError = (hex[3] & 0x08) != 0
	//sixth and seven bit are unused, eigth bit return bool
	dec.RequestBackupData = (hex[3] & 0x01) != 0

	return dec
}
