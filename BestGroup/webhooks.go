package main

import (
	"encoding/json"
	"io/ioutil"
	"net/http"
)

func PostService(w http.ResponseWriter, r *http.Request) {
	if len(r.URL.Path) > 50 {
		r.URL.Path = r.URL.Path[:50]
	}

	logrequest(r)
	// check if the option ?format is present and get the value
	// format := r.URL.Query().Get("format")
	println("called")

	// //print all request
	// for key, value := range r.URL.Query() {
	// 	println(key, value)
	// }
	// for key, value := range r.Header {
	// 	println(key, value)
	// }

	//get or post
	println(r.Method)
	switch r.Method {
	case http.MethodPost:
		// read the body
		body, err := ioutil.ReadAll(r.Body)
		if err != nil {
			loganswer("Error reading body")
			println("Error reading body")
			http.Error(w, "can't read body", http.StatusBadRequest)
			return
		}
		//translate json to AutoGenerated
		var no Node
		if err := json.Unmarshal(body, &no); err != nil {
			loganswer("Error unmarshalling json")
			println("Error unmarshalling json")
			http.Error(w, "can't unmarshal json", http.StatusBadRequest)
			return
		}

		//get value of the key "frm_payload" in key "uplink_message"
		no.UplinkMessage.FrmPayload = base64ToHex(no.UplinkMessage.FrmPayload)

		//add dat to Nodes of type AutoGenerated
		Nodes.Nodes = append(Nodes.Nodes, no)

		//save the Nodes in end-nodes.json
		err = SaveJSON("end-nodes.json")
		if err != nil {
			loganswer("Error saving json")
			println("Error saving json")
			http.Error(w, "can't save json", http.StatusBadRequest)
			return
		}

		loganswer("request validated")
		w.WriteHeader(http.StatusAccepted)
	case http.MethodGet:

		w.WriteHeader(http.StatusMethodNotAllowed)
		println("Method not allowed")
		loganswer("Method not allowed")
	default:
		w.WriteHeader(http.StatusMethodNotAllowed)
		println("Method not allowed")
		loganswer("Method not allowed")
	}
}
