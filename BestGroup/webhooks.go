package main

import (
	"encoding/hex"
	"encoding/json"
	"io/ioutil"
	"net/http"
)

func PostService(w http.ResponseWriter, r *http.Request) {
	if len(r.URL.Path) > 50 {
		r.URL.Path = r.URL.Path[:50]
	}

	logrequest(r)
	// check if the option ?format is present and get the value
	// format := r.URL.Query().Get("format")
	println("called")

	// //print all request
	// for key, value := range r.URL.Query() {
	// 	println(key, value)
	// }
	// for key, value := range r.Header {
	// 	println(key, value)
	// }

	//get or post
	println(r.Method)
	switch r.Method {
	case http.MethodPost:
		// read the body
		body, err := ioutil.ReadAll(r.Body)
		if err != nil {
			loganswer("Error reading body")
			println("Error reading body")
			http.Error(w, "can't read body", http.StatusBadRequest)
			return
		}
		//translate json to AutoGenerated
		var no Node
		if err := json.Unmarshal(body, &no); err != nil {
			loganswer("Error unmarshalling json")
			println("Error unmarshalling json")
			http.Error(w, "can't unmarshal json", http.StatusBadRequest)
			return
		}

		if len(Nodes.Nodes) != 0 {
			//search newest node id and add 1
			no.ID = Nodes.Nodes[len(Nodes.Nodes)-1].ID + 1
		} else {
			no.ID = 1
		}

		//if no.Simulated exists then do base64Tohex
		if no.Simulated {
			no.UplinkMessage.FrmPayload = base64tohex(no.UplinkMessage.FrmPayload)
		} else {
			//get value of the key "frm_payload" in key "uplink_message"
			no.UplinkMessage.FrmPayload = base64Toutf8(no.UplinkMessage.FrmPayload)
		}

		//add dat to Nodes of type AutoGenerated
		Nodes.Nodes = append(Nodes.Nodes, no)
		Nodes.Decrypted = append(Nodes.Decrypted, Decrypt(no.UplinkMessage.FrmPayload))

		if len(Nodes.Decrypted) != 0 {
			//search newest node id and add no.ID
			Nodes.Decrypted[len(Nodes.Decrypted)-1].ID = no.ID
		} else {
			Nodes.Decrypted[0].ID = no.ID
		}

		//save the Nodes in end-nodes.json
		err = SaveJSON("end-nodes.json", Nodes, Users{})
		if err != nil {
			loganswer("Error saving json")
			println("Error saving json")
			http.Error(w, "can't save json", http.StatusBadRequest)
			return
		}

		loganswer("request validated")
		w.WriteHeader(http.StatusAccepted)
	case http.MethodGet:

		w.WriteHeader(http.StatusMethodNotAllowed)
		println("Method not allowed")
		loganswer("Method not allowed")
	default:
		w.WriteHeader(http.StatusMethodNotAllowed)
		println("Method not allowed")
		loganswer("Method not allowed")
	}
}

func Decrypt(hexstring string) Decrypted {
	dec := Decrypted{}
	//convert hexstring to byte array
	hex, err := hex.DecodeString(hexstring)
	if err != nil {
		println("Error decoding hexstring")
		return dec
	}
	// get 1st byte and convert it to int
	dec.LEDBrightness = int(hex[0])

	// get 2nd byte and convert it to int
	dec.LEDUsage = int(hex[1])

	// get 3rd byte and convert it to int
	dec.DeadLEDs = int(hex[2])

	// get 4th byte and get it bit by bit
	//first bit return bool
	dec.IsPowered = (hex[3] & 0x80) != 0
	//second bit return bool
	dec.ZMCTError = (hex[3] & 0x40) != 0
	//third bit return bool
	dec.XY_MOSError = (hex[3] & 0x20) != 0
	//fourth bit return bool
	dec.ACSError = (hex[3] & 0x10) != 0
	//fifth bit return bool
	dec.PhotoresistorError = (hex[3] & 0x08) != 0
	//sixth and seven bit are unused, eigth bit return bool
	dec.RequestBackupData = (hex[3] & 0x01) != 0

	return dec
}
